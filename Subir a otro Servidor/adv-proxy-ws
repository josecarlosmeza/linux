#!/bin/bash

# ======================================================
# 1. INSTALACIÃ“N DE DEPENDENCIAS Y OPTIMIZACIÃ“N
# ======================================================
echo "ðŸ“¦ Instalando dependencias y optimizando sistema..."
dnf install -y python3 python3-pip procps-ng net-tools
mkdir -p /opt/advanced-proxy

# Liberar puertos 80 y 443 por si estÃ¡n ocupados
fuser -k 80/tcp 2>/dev/null
fuser -k 443/tcp 2>/dev/null

# Ajustar lÃ­mites de archivos abiertos (Ulimit)
cat <<EOF > /etc/security/limits.d/proxy.conf
* soft nofile 65535
* hard nofile 65535
root soft nofile 65535
root hard nofile 65535
EOF

# ======================================================
# 2. CREACIÃ“N DEL SCRIPT PROXY CON VIRTUDES
# ======================================================
cat <<EOF > /opt/advanced-proxy/proxy.py
import asyncio, hashlib, base64, gc

# ==============================================================================
# âš™ï¸ BLOQUE DE PARÃMETROS (AJUSTABLES)
# ==============================================================================
# Detalle:                        Valor:         DescripciÃ³n:
# ------------------------------------------------------------------------------
PORTS          = [80, 443]        # [80, 443]    Puertos de escucha
PASS           = 'mi_password'    # string       ContraseÃ±a para X-Pass
TARGET_IP      = '127.0.0.1'      # IP           IP de SSHD
TARGET_PORT    = 22               # 22           Puerto de SSHD (sshd)
BUFFER_SIZE    = 16384            # 16384 (16KB) Estabilidad de velocidad
KEEP_ALIVE_SEC = 25               # 25           Evita cierre de CloudFront
RAM_CLEAN_SEC  = 300              # 300 (5min)   Mantiene el VPS ligero
# ==============================================================================

# GuÃ­a para HTTP Custom:
# Payload: GET / HTTP/1.1[crlf]Host: [dominio_cloudfront][crlf]Upgrade: websocket[crlf]Connection: Upgrade[crlf]X-Pass: mi_password[crlf][crlf]

def generate_ws_accept(key):
    GUID = b"258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
    sha1 = hashlib.sha1(key + GUID).digest()
    return base64.b64encode(sha1).decode()

def find_header(head, header):
    try:
        start = head.lower().find(header.lower() + b': ')
        if start == -1: return b''
        start += len(header) + 2
        end = head.find(b'\r\n', start)
        return head[start:end].strip()
    except: return b''

async def memory_cleaner():
    """Virtud: Libera RAM sin afectar conexiones activas."""
    while True:
        await asyncio.sleep(RAM_CLEAN_SEC)
        gc.collect()

async def forward(reader, writer):
    """Virtud: Manejo de contrapresiÃ³n y estabilidad de flujo."""
    try:
        while True:
            try:
                data = await asyncio.wait_for(reader.read(BUFFER_SIZE), timeout=KEEP_ALIVE_SEC)
                if not data: break
                
                writer.write(data)
                
                # Si el bÃºfer se llena, pausamos para no saturar la red (Backpressure)
                if writer.transport.get_write_buffer_size() > 65536:
                    await writer.drain()
            except asyncio.TimeoutError:
                # Mantiene el tÃºnel vivo enviando un bit de actividad
                writer.write(b'\x00')
                await writer.drain()
            except (ConnectionResetError, BrokenPipeError):
                break
    except: pass
    finally:
        try:
            writer.close()
            await writer.wait_closed()
        except: pass

async def handle(client_reader, client_writer):
    try:
        data = await asyncio.wait_for(client_reader.read(4096), timeout=10)
        if not data: return
        
        passwd = find_header(data, b'X-Pass').decode('latin-1')
        if PASS and passwd != PASS:
            client_writer.write(b"HTTP/1.1 403 Forbidden\r\n\r\n")
            await client_writer.drain()
            return

        ws_key = find_header(data, b'Sec-WebSocket-Key')
        accept_val = generate_ws_accept(ws_key) if ws_key else "AnyValue"
        
        target_reader, target_writer = await asyncio.open_connection(TARGET_IP, TARGET_PORT)
        
        resp = ("HTTP/1.1 101 Switching Protocols\r\n"
                "Upgrade: websocket\r\n"
                "Connection: Upgrade\r\n"
                "Sec-WebSocket-Accept: %s\r\n"
                "Server: nginx/1.24.0\r\n\r\n" % accept_val).encode('latin-1')
        
        client_writer.write(resp)
        await client_writer.drain()

        await asyncio.gather(
            forward(client_reader, target_writer),
            forward(target_reader, client_writer)
        )
    except: pass
    finally:
        try: client_writer.close()
        except: pass

async def start_servers():
    asyncio.create_task(memory_cleaner())
    tasks = [asyncio.start_server(handle, '0.0.0.0', p) for p in PORTS]
    servers = await asyncio.gather(*tasks)
    await asyncio.gather(*[s.serve_forever() for s in servers])

if __name__ == '__main__':
    try:
        asyncio.run(start_servers())
    except KeyboardInterrupt:
        pass
EOF

# ======================================================
# 3. CONFIGURACIÃ“N DEL SERVICIO SYSTEMD
# ======================================================
cat <<EOF > /etc/systemd/system/adv-proxy.service
[Unit]
Description=Advanced MultiPort Proxy (SSHD + CloudFront)
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/advanced-proxy
ExecStart=/usr/bin/python3 /opt/advanced-proxy/proxy.py
Restart=always
RestartSec=3
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
EOF

# ======================================================
# 4. LANZAMIENTO
# ======================================================
systemctl daemon-reload
systemctl enable adv-proxy
systemctl restart adv-proxy

echo "-------------------------------------------------------"
echo "âœ… TODO LISTO"
echo "âœ… Proxy estable en puertos: 80 y 443"
echo "âœ… ConfiguraciÃ³n de SSHD optimizada"
echo "âœ… Limpiador de RAM y Control de Flujo ACTIVADOS"
echo "-------------------------------------------------------"
