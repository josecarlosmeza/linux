#!/bin/bash
clear

# --- CONFIGURACIÃ“N DE ARCHIVOS ---
database="/root/usuarios.db"
if [ -f /var/log/secure ]; then
    AUTH_LOG_FILE="/var/log/secure"
elif [ -f /var/log/auth.log ]; then
    AUTH_LOG_FILE="/var/log/auth.log"
else
    AUTH_LOG_FILE="/var/log/messages"
fi
# --- FIN CONFIGURACIÃ“N ---

# --- OPTIMIZACIÃ“N CRÃTICA: FILTRADO DE LOGS Y PROCESOS ---

echo "Preparando historial reciente del log (Ãºltimas 24 horas)..."
# 1. Filtro de log: Se ejecuta una sola vez al inicio para velocidad.
RECENT_LOG_LINES=$(sudo journalctl --since "24 hours ago" _COMM=sshd _COMM=dropbear --no-pager 2>/dev/null)
JOURNAL_STATUS=$? 

if [ $JOURNAL_STATUS -ne 0 ] && [ -z "$RECENT_LOG_LINES" ]; then
    echo "ğŸš¨ ERROR: Fallo al leer logs con 'sudo journalctl'. Verifique los permisos de sudo."
    echo "         El conteo de sesiones activas puede ser INCOMPLETO."
    RECENT_LOG_LINES=""
fi

echo "Historial listo."

# Capturamos todos los PIDs activos de SSH/Dropbear en una sola pasada (sin Zombies [Z] ni Stop [T]).
ALL_ACTIVE_PIDS=$(ps axo pid,user,stat,cmd | grep -E '(sshd|dropbear)' | grep -v -E ' Z | T ')

# --- FUNCIONES AUXILIARES (Mantenidas) ---
calculate_session_time_bc() {
    local tmp1=$1;
    local tmp2=$(date +%H:%M:%S 2>/dev/null)
    if [[ -z "$tmp1" ]] || [[ -z "$tmp2" ]]; then echo "??:??:??"; return; fi
    var1=`echo $tmp1 | cut -c 1-2`; var2=`echo $tmp1 | cut -c 4-5`; var3=`echo $tmp1 | cut -c 7-8`
    var4=`echo $tmp2 | cut -c 1-2`; var5=`echo $tmp2 | cut -c 4-5`; var6=`echo $tmp2 | cut -c 7-8`
    calc1=`echo "$var1*3600 + $var2*60 + $var3" | bc 2>/dev/null`;
    calc2=`echo "$var4*3600 + $var5*60 + $var6" | bc 2>/dev/null`
    if [[ -z "$calc1" ]] || [[ -z "$calc2" ]]; then echo "??:??:??"
    return; fi
    seg=$(($calc2 - $calc1));
    if [ $seg -lt 0 ]; then seg=$((seg + 86400)); fi
    min=$(($seg/60)); seg=$(($seg-$min*60)); hor=$(($min/60)); min=$(($min-$hor*60))
    timerusr=`printf "%02d:%02d:%02d" $hor $min $seg;`; echo "$timerusr"
}

get_ssh_log_time() {
    local user=$1;
    local log=$AUTH_LOG_FILE;
    local LOG_ENTRY=$(grep -E 'Accepted|session opened|login|auth succeeded' "$log" | grep -w "$user" | tail -1) 
    if [ -z "$LOG_ENTRY" ]; then echo ""; return; fi
    tmp1=$(echo "$LOG_ENTRY" | awk '{print $3}' | tr -d '[:space:]');
    echo "$tmp1"
}

extract_pids_from_log() {
    local log_lines="$1"
    local pids=""

    pids+=$(echo "$log_lines" | grep "dropbear" | sed -E 's/.*dropbear\[([0-9]+)\].*/\1/')
    pids+=" "
    pids+=$(echo "$log_lines" | grep "sshd" | sed -E 's/.*sshd\[([0-9]+)\].*/\1/')

    echo "$pids" | tr ' ' '\n' | grep -v '^$' | sort -u
}

# --- FUNCIÃ“N CENTRAL: CONTEO PRECISO (Dropbear + sshd) ---
get_active_session_count() {
    local target_user=$1
    local log_subset="$RECENT_LOG_LINES"

    local active_count=0
    local oldest_pid=""

    # 1. Filtramos el SUBSET de log (24 horas) por el usuario y Ã©xito
    SUCCESS_LINES=$(echo "$log_subset" | grep -E 'Accepted password|Password auth succeeded|session opened' | grep -w "$target_user")

    if [[ -n "$SUCCESS_LINES" ]]; then
        
        # 2. Extraer todos los PIDs registrados del log para este usuario
        REGISTERED_PIDS=$(extract_pids_from_log "$SUCCESS_LINES")

        # 3. Verificar la actividad comparando con la lista GLOBAL de PIDs activos
        for pid in $REGISTERED_PIDS; do
            
            # Buscamos el PID en la lista que ya estÃ¡ en memoria (ALL_ACTIVE_PIDS)
            if echo "$ALL_ACTIVE_PIDS" | grep -w "^$pid" > /dev/null; then
                
                active_count=$((active_count + 1))
                
                # Identificar el PID activo mÃ¡s antiguo
                if [[ -z "$oldest_pid" ]] || [[ "$pid" -lt "$oldest_pid" ]]; then
                    oldest_pid="$pid"
                fi
            fi
        done
    fi

    echo "$active_count $oldest_pid" 
}

# --- INICIO DEL PROGRAMA PRINCIPAL ---
if [[ -e /usr/lib/licence ]]; then

TOTAL_SESSIONS=0

echo -e "\E[44;1;37m Usuario        Estado        ConexiÃ³n        Tiempo   \E[0m"
echo ""
echo ""

while IFS=' ' read -r user s2ssh _ 
do  
    # âš¡ MEJORA: Limpieza de variables con expansiÃ³n nativa de Bash (sin subshells)
    # Elimina espacios al inicio o final de las variables
    user="${user//[[:space:]]/}"
    s2ssh="${s2ssh//[[:space:]]/}"
    
    # Obtener el conteo preciso de sesiones activas y el PID mÃ¡s antiguo
    read -r session_count OLDEST_PID < <(get_active_session_count "$user")
    
    [[ "$session_count" = "" ]] && session_count=0
    timerr="00:00:00"

 
    # --- CÃLCULO DEL TIEMPO DE SESIÃ“N ---
    if [[ $session_count -gt 0 ]]; then
      tst=""
      
      TOTAL_SESSIONS=$((TOTAL_SESSIONS + session_count))
      
      # 1. Intentar obtener el tiempo del PID mÃ¡s antiguo
      if [[ -n "$OLDEST_PID" ]]; then
          tst="$(ps -o etime -p "$OLDEST_PID" 2>/dev/null | awk 'NR==2 {print $1}')"
      fi

      if [[ -n "$tst" ]]; then
          timerr="$tst" 
      else
          # Fallback: Usar la hora de inicio del log (mÃ¡s lento, solo como respaldo)
          log_start_time=$(get_ssh_log_time "$user")
          if [[ -n "$log_start_time" ]]; then
              timerr=$(calculate_session_time_bc "$log_start_time")
          else
              timerr="??:??:??"
          fi
      fi
      
      # 2. Limitar el conteo a mostrar al mÃ¡ximo permitido por el usuario (s2ssh)
      if [ "$session_count" -gt "$s2ssh" ]; then
          session_count=$s2ssh
      fi
    fi
    # --- FIN CÃLCULO DEL TIEMPO Y CONTEO ---

    # --- MOSTRAR RESULTADOS ---
    if [[ $session_count -eq 0 ]]; then
       status=$(echo -e "\033[1;31mOffline \033[1;33m       ")
       echo -ne "\033[1;33m"
       printf '%-17s%-14s%-10s%s\n' " $user" "$status" "0/$s2ssh" "$timerr" 
    else
       status=$(echo -e "\033[1;32mOnline\033[1;33m         ")
       echo -ne "\033[1;33m"
       printf '%-17s%-14s%-10s%s\n' " $user" "$status" "$session_count/$s2ssh" "$timerr"
    fi
    echo -e "\033[0;34mâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\033[0m"
    
done < "$database"

# --- RESUMEN FINAL ---
echo -e "\n\E[44;1;37m Sesiones Totales Activas: $TOTAL_SESSIONS \E[0m"

echo -e "\033[0m" 
f
i
