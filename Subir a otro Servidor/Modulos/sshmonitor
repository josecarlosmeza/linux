#!/bin/bash
clear

# --- CONFIGURACIÓN DE ARCHIVOS ---
database="/root/usuarios.db"
LOG_FILE="/var/log/secure" # En AlmaLinux/RHEL, 'secure' es el archivo de log principal para autenticación.
# En algunos sistemas puede seguir siendo /var/log/auth.log o /var/log/messages

# Verificación de la licencia (ruta original, mantengo por compatibilidad con el código anterior)
if [[ -e /usr/lib/licence ]]; then

# Variable temporal para cálculos de tiempo (no siempre necesaria, pero mantenida)
tmp_now=$(printf '%(%H%M%S)T\n')

# --- FUNCIÓN PARA DROPBEAR (Requiere un formato de log estable) ---
fun_drop () {
    # 1. Obtener el PID principal del servidor dropbear (para el puerto, si fuera necesario)
    # port_dropbear=`ss -lntp | grep dropbear | awk '{print $4}' | cut -d: -f2 | head -1`

    # 2. Obtener PIDs de procesos dropbear (las sesiones activas)
    # Se usa awk para imprimir el PID (columna 2) solo si el comando contiene 'dropbear' y no es el grep
    DROPBEAR_PIDS=$(ps aux | awk '/dropbear/ && !/awk/ && !/grep/ {print $2}')
    
    log=$LOG_FILE
    loginsukses='Password auth succeeded'
    
    echo "Dropbear Sessions:"
    
    # Iterar sobre las sesiones activas
    for pid in $DROPBEAR_PIDS
    do
        # Intenta encontrar el usuario asociado al PID en el log
        # Nota: La estructura del log varía. Esta es una suposición basada en el código original.
        # Buscamos la línea de éxito para el PID
        login=`grep "$pid" $log | grep "$loginsukses" | tail -1`

        if [ -n "$login" ];then
           PID=$pid
           # Ajustar el campo de AWK basado en el formato de /var/log/secure o /var/log/auth.log
           # En muchas distribuciones, el usuario es el último campo después de 'for USER from IP...'
           user=`echo "$login" | grep -oP '(?<=for ).*(?= from)' | awk '{print $1}' | sed "s/'//g"`
           
           # Si el método anterior falla, usar la lógica original (basada en posición fija, menos robusta)
           if [ -z "$user" ]; then
             user=`echo "$login" | awk -F" " '{print $10}' | sed -r "s/'/ /g"`
           fi

           waktu=$(ps -o etime -p $pid | awk 'NR==2 {print $1}')

           while [ ${#waktu} -lt 13 ]; do
               waktu=$waktu" "
           done
           while [ ${#user} -lt 16 ]; do
               user=$user" "
           done
           while [ ${#PID} -lt 8 ]; do
               PID=$PID" "
           done
           echo "    $user $PID $waktu"
        fi
    done
}
# --- FIN FUNCIÓN DROPBEAR ---

echo -e "\E[44;1;37m Usuario        Estado        Conexión        Tiempo   \E[0m"
echo ""
echo ""

while read usline
do  
    user="$(echo $usline | cut -d' ' -f1)"
    s2ssh="$(echo $usline | cut -d' ' -f2)" # Límite de conexiones permitidas
    
    # 1. SSHD Connections (más robusto con pgrep)
    if [ "$(cat /etc/passwd| grep -w $user| wc -l)" = "1" ]; then
      sqd=$(pgrep -u "$user" sshd | wc -l)
    else
      sqd=0
    fi
    [[ "$sqd" = "" ]] && sqd=0
    
    # 2. OpenVPN Connections
    if [[ -e /etc/openvpn/openvpn-status.log ]]; then
      ovp="$(grep -E ",$user," /etc/openvpn/openvpn-status.log | wc -l)"
    else
      ovp=0
    fi
    
    # 3. Dropbear Connections (usando la función)
    drop=0
    if netstat -nltp | grep 'dropbear' > /dev/null; then
      # Ejecutar la función y contar las líneas que contienen el usuario
      # Se asume que fun_drop devuelve la lista de sesiones dropbear activas.
      DROPBEAR_SESSIONS=$(fun_drop | grep -w "$user" | awk '{print $2}')
      drop=$(echo "$DROPBEAR_SESSIONS" | wc -l)
    fi
    
    cnx=$(($sqd + $drop)) # Total SSH/Dropbear
    conex=$(($cnx + $ovp)) # Total SSH/Dropbear/OpenVPN

    timerr="00:00:00"

    # --- CALCULO DEL TIEMPO DE SESIÓN ---
    if [[ $cnx -gt 0 ]]; then
      # Obtener el PID más antiguo de SSHD para el tiempo de sesión más largo (representativo)
      OLDEST_SSHD_PID=$(pgrep -u "$user" sshd | sort -n | head -1)
      
      if [[ -n "$OLDEST_SSHD_PID" ]]; then
          tst="$(ps -o etime -p "$OLDEST_SSHD_PID" | awk 'NR==2 {print $1}')"
      else
          # Fallback para Dropbear si SSHD no está activo pero Dropbear sí
          if [[ $drop -gt 0 ]]; then
             # En un entorno real, necesitarías obtener el PID más antiguo de Dropbear aquí.
             # Para simplificar y evitar más parsing de logs, se usa el tiempo del primer PID encontrado en la función
             # Pero en este script, usaremos el mismo método que SSHD (puede que no sea preciso para Dropbear)
             tst="??:??:??" # Marcador para indicar que el tiempo no es fácil de obtener sin el PID
          fi
      fi
      
      # Formato de tiempo para SSHD/Dropbear
      tst1=$(echo "$tst" | wc -c)
      if [[ "$tst1" == "9" ]]; then 
          timerr="$tst" # Formato ya incluye días D-HH:MM:SS
      elif [[ -n "$tst" ]]; then
          timerr="00:$tst"
      fi

    elif [[ $ovp -gt 0 ]]; then
      # Cálculo de tiempo para OpenVPN
      tmp2=$(printf '%(%H:%M:%S)T\n')
      tmp1="$(grep -w "$user" /etc/openvpn/openvpn-status.log | awk '{print $4}' | head -1)"
      [[ "$tmp1" = "" ]] && tmp1="00:00:00" && tmp2="00:00:00"
      
      # Se mantiene la lógica de cálculo con 'bc'
      var1=`echo $tmp1 | cut -c 1-2`
      var2=`echo $tmp1 | cut -c 4-5`
      var3=`echo $tmp1 | cut -c 7-8`
      var4=`echo $tmp2 | cut -c 1-2`
      var5=`echo $tmp2 | cut -c 4-5`
      var6=`echo $tmp2 | cut -c 7-8`
      
      calc1=`echo "$var1*3600 + $var2*60 + $var3" | bc`
      calc2=`echo "$var4*3600 + $var5*60 + $var6" | bc`
      
      seg=$(($calc2 - $calc1))
      min=$(($seg/60))
      seg=$(($seg-$min*60))
      hor=$(($min/60))
      min=$(($min-$hor*60))
      timerusr=`printf "%02d:%02d:%02d \n" $hor $min $seg;`
      timerr=$(echo "$timerusr" | sed -e 's/[^0-9:]//ig' )
    fi
    # --- FIN CALCULO DEL TIEMPO DE SESIÓN ---

    # --- MOSTRAR RESULTADOS ---
    if [[ $conex -eq 0 ]]; then
       status=$(echo -e "\033[1;31mOffline \033[1;33m       ")
       echo -ne "\033[1;33m"
       printf '%-17s%-14s%-10s%s\n' " $user"        "$status"        "$conex/$s2ssh"        "$timerr" 
    else
       status=$(echo -e "\033[1;32mOnline\033[1;33m         ")
       echo -ne "\033[1;33m"
       printf '%-17s%-14s%-10s%s\n' " $user"        "$status"        "$conex/$s2ssh"        "$timerr"
    fi
    echo -e "\033[0;34m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\033[0m"
    
done < "$database"

fi
#exit
