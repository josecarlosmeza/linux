#!/bin/bash

# ===============================================
# CONFIGURACIÓN
# ===============================================

# 1. Rutas y Colores
DATABASE="/root/usuarios.db"
LOG_AUTH="/var/log/auth.log"  # Se mantiene por compatibilidad si no se usa journalctl
CLEAR='\033[0m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[1;31m'
GREEN='\033[1;32m'
BG_HEADER='\E[44;1;37m'
RESET_BG='\E[0m'

clear

# Verificar el archivo de licencia o configuración
if [[ -e /usr/lib/licence ]]; then

# ===============================================
# FUNCIONES
# ===============================================

# Función optimizada para Dropbear (Mejor usar ps/pgrep directamente)
fun_drop () {
    # Busca procesos Dropbear que NO son el ejecutable principal (son las sesiones)
    # y filtra por el usuario. Mucho más fiable que parsear logs.
    
    # Intenta determinar el PID del proceso padre de Dropbear para excluirlo
    DROPBEAR_MASTER_PID=$(pgrep -f "dropbear -d")
    
    # Se lista la sesión Dropbear y el tiempo (etime)
    # Se excluye el PID del proceso padre/master.
    ps -eo user,pid,etime,cmd | awk -v master_pid="$DROPBEAR_MASTER_PID" '
        $4 ~ /dropbear/ && $2 != master_pid { 
            print $1 " " $2 " " $3 
        }
    ' 
    # La salida es: [usuario] [PID] [tiempo]
}

# ===============================================
# SALIDA E INICIO DEL MONITOR
# ===============================================

echo -e "${BG_HEADER} Usuario         Status       Conexão     Tiempo   ${RESET_BG}"
echo ""

while read usline
do  
    # Lectura del usuario y límite de conexiones
    [span_0](start_span)user="$(echo $usline | cut -d' ' -f1)"[span_0](end_span)
    [span_1](start_span)s2ssh="$(echo $usline | cut -d' ' -f2)"[span_1](end_span)
    
    # 1. VERIFICACIÓN DE EXISTENCIA DEL USUARIO
    [span_2](start_span)if [ "$(cat /etc/passwd| grep -w $user| wc -l)" = "1" ]; then[span_2](end_span)
        # 2. CONTEO DE SESIONES SSHD (Optimizado con pgrep)
        # -c cuenta las ocurrencias sin necesidad de wc -l
        sqd=$(pgrep -u "$user" -c sshd)
    else
        sqd=0
    fi
    
    # 3. CONTEO DE SESIONES DROPBEAR (Usando la función optimizada)
    if netstat -nltp|grep 'dropbear' > /dev/null; then
        # Contar cuantas líneas de Dropbear pertenecen al usuario
        [span_3](start_span)drop=$(fun_drop | grep -w "$user" | wc -l)[span_3](end_span)
    else
        [span_4](start_span)drop=0[span_4](end_span)
    fi
    
    # 4. CONTEO DE SESIONES OPENVPN (Optimizado con grep -c)
    [span_5](start_span)if [[ -e /etc/openvpn/openvpn-status.log ]]; then[span_5](end_span)
        # grep -c cuenta las líneas, más eficiente que wc -l
        [span_6](start_span)ovp=$(grep -c ",$user," /etc/openvpn/openvpn-status.log)[span_6](end_span)
    else
        [span_7](start_span)ovp=0[span_7](end_span)
    fi
    
    # CÁLCULO DE CONEXIONES TOTALES
    [span_8](start_span)cnx=$((sqd + drop))[span_8](end_span)
    [span_9](start_span)conex=$((cnx + ovp))[span_9](end_span)

    # ===============================================
    # CÁLCULO DEL TIEMPO (ETime)
    # ===============================================
    
    [span_10](start_span)timerr="00:00:00" # Valor por defecto[span_10](end_span)
    
    [span_11](start_span)if [[ $cnx -gt 0 ]]; then[span_11](end_span)
        # SSHD/DROPBEAR: Obtener el tiempo de ejecución (ETIME) del primer proceso SSHD/Dropbear
        # Busca el PID del proceso SSHD o Dropbear más antiguo del usuario
        FIRST_PID=$( (pgrep -u "$user" sshd; pgrep -u "$user" dropbear) | sort -n | head -1)

        if [[ -n "$FIRST_PID" ]]; then
            # ps -o etime es el método más fiable para tiempo transcurrido en SSH/Dropbear
            [span_12](start_span)tst=$(ps -o etime --no-headers -p "$FIRST_PID" | awk '{print $1}')[span_12](end_span)

            # Formateo del tiempo (maneja DÍAS-HORAS:MINUTOS:SEGUNDOS)
            if [[ $tst =~ ^([0-9]+)- ]]; then
                # Si contiene días (ej. 1-05:10:30)
                timerr="$tst"
            elif [[ ${#tst} -lt 9 ]]; then
                # Si solo tiene HH:MM:SS o M:SS, añade ceros si es necesario
                timerr=$(printf "%08s" "$tst" | sed 's/ /0/g') 
            else
                timerr="$tst"
            fi
        fi

    [span_13](start_span)elif [[ $ovp -gt 0 ]]; then[span_13](end_span)
        # OPENVPN: Se asume que el campo 4 es el tiempo transcurrido (HH:MM:SS) en el log
        
        # Se extrae el campo 4 que contiene el tiempo transcurrido (ej. "02:30:15")
        # El cálculo complejo original se elimina y se usa el valor directamente.
        OVPN_TIME=$(grep -w "$user" /etc/openvpn/openvpn-status.log | awk -F ',' '{print $4}' | head -1)

        # Validación simple y asignación
        if [[ "$OVPN_TIME" =~ ^[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
            timerr="$OVPN_TIME"
        else
            timerr="OVPN_ERR"
        fi
        
    fi

    # ===============================================
    # SALIDA FINAL (Optimizado el manejo de color)
    # ===============================================
    
    [span_14](start_span)if [[ $conex -eq 0 ]]; then[span_14](end_span)
        [span_15](start_span)status=$(echo -e "${RED}Offline${YELLOW}")[span_15](end_span)
    else
        [span_16](start_span)status=$(echo -e "${GREEN}Online${YELLOW}")[span_16](end_span)
    fi

    [span_17](start_span)echo -ne "${YELLOW}"[span_17](end_span)
    printf '%-17s%-14s%-10s%s\n' " $user"      "$status" "$conex/$s2ssh" "$timerr" 
    [span_18](start_span)echo -e "${BLUE}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${CLEAR}"[span_18](end_span)
    
done < "$DAT
                            ABASE"

fi
#exit
