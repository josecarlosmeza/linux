#!/bin/bash

# ==========================================================
# CONFIGURACIÓN
# ==========================================================
tput setaf 7 ; tput setab 4 ; tput bold ; printf '%20s%s\n' "   Alterar limite de conexões simultâneas   " ; tput sgr0
database="/root/usuarios.db"

# Declarar array asociativo para almacenar límites (Requiere Bash >= 4.0)
declare -A LIMITES
i=0 # Contador global

# ==========================================================
# PASO 1: CARGAR LÍMITES DE CONEXIÓN DEL DISCO A MEMORIA (Una sola vez)
# ==========================================================
if [ -f "$database" ]; then
    # Usamos 'while read' con IFS para leer el archivo de límites eficientemente
    while IFS=" " read -r user limit other; do
        [[ -n "$user" ]] && LIMITES["$user"]="$limit"
    done < "$database"
else
	tput setaf 7 ; tput setab 1 ; tput bold ; echo "" ; echo "Archivo $database no encontrado" ; echo "" ; tput sgr0
	exit 1
fi

# ==========================================================
# PASO 2: GENERAR LISTA DE USUARIOS Y MOSTRAR LÍMITES (Desde memoria)
# ==========================================================
tput setaf 3 ; tput bold ; echo ""; echo "LISTA DE USUARIOS Y SUS LIMITES:" ; tput sgr0
echo ""

# Obtenemos usuarios de shell y procesamos la lista en el bucle principal
_userT=$(awk -F: '$3>=1000 {print $1}' /etc/passwd | grep -v nobody)
unset _userPass # Variable para almacenar la lista de opciones (número:usuario)

while read -r _user; do
    ((i++)) # Moderno: Incremento de contador Bash
    _oP="$i"
    
    # Obtener límite desde la MATRIZ EN MEMORIA. Por defecto es '1'
    limit="${LIMITES[$_user]:-1}" 
    
    # Formato de número de opción (01, 02, etc.)
    if [[ $i -lt 10 ]]; then 
        i_display="0$i" 
    else
        i_display="$i"
    fi
    
    # Construir líneas de visualización y de opciones
    l_user=$(echo -e "\033[1;31m[\033[1;36m$i_display\033[1;31m] \033[1;37m- \033[1;32m$_user\033[0m")
    lim=$(echo -e "\033[1;33mLimite\033[1;37m: $limit")
    
    printf '%-65s%s\n' "$l_user" "$lim"
    _userPass+="\n${_oP}:${_user}"
done <<< "${_userT}"

# ==========================================================
# PASO 3: SELECCIÓN Y VALIDACIÓN
# ==========================================================
echo ""
num_user="$i"
echo -ne "\033[1;32mDigite ou selecione um usuario \033[1;33m[\033[1;36m1\033[1;31m-\033[1;36m$num_user\033[1;33m]\033[1;37m: " ; read option

usuario=$(echo -e "${_userPass}" | grep -E "\b$option\b" | cut -d: -f2)

if [[ -z $option || -z $usuario ]]; then
    tput setaf 7 ; tput setab 1 ; tput bold ; echo "" ; echo "Usuário vazio ou não existente" ; echo "" ; tput sgr0
    exit 1
elif ! cat /etc/passwd |grep -w "$usuario" > /dev/null; then
    tput setaf 7 ; tput setab 1 ; tput bold ; echo "" ; echo "O usuário $usuario não foi encontrado" ; echo "" ; tput sgr0
    exit 1
fi

echo -ne "\n\033[1;32mNovo limite para o usuario \033[1;33m$usuario\033[1;37m: "; read sshnum

# Validación más limpia de número
if ! [[ "$sshnum" =~ ^[1-9][0-9]*$ ]]; then
    tput setaf 7 ; tput setab 1 ; tput bold ; echo "" ; echo "Você digitou um número inválido ou menor que um!" ; echo "" ; tput sgr0
    exit 1
else
    # ==========================================================
    # PASO 4: ACTUALIZACIÓN (Mantiene la lógica robusta de edición)
    # ==========================================================
    # 1. Elimina la línea antigua del usuario y guarda el resto en un temporal.
    grep -v "^$usuario[[:space:]]" "$database" > /tmp/usuarios_db_temp
    
    # 2. Mueve el temporal para reemplazar el original.
    mv /tmp/usuarios_db_temp "$database"
    
    # 3. Añade la nueva configuración al final.
    echo "$usuario $sshnum" >> "$database"
    
    tput setaf 7 ; tput setab 4 ; tput bold ; echo "" ; echo "Limite aplicado para o usuário $usuario foi $sshnum " ; tput sgr0
    sleep 2
    exit
fi
