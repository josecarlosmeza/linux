#!/bin/bash
clear
database="/root/usuarios.db"

# ==========================================================
# PASO 1: PRE-CARGA DE LÍMITES EN UN ARRAY ASOCIATIVO (Bash >= 4.0)
# ==========================================================
if ! declare -A LIMITS 2>/dev/null; then
    echo "ERROR: Bash 4.0 o superior es requerido para usar arrays asociativos."
    # Si Bash < 4.0, se podría usar un archivo temporal o un enfoque menos eficiente.
    exit 1
fi

if [[ -f "$database" ]]; then
    while IFS=" " read -r user limit other; do
        [[ -n "$user" && -n "$limit" ]] && LIMITS[$user]="$limit"
    done < "$database"
fi

# ==========================================================
# PASO 2: FUNCIÓN DE MULTILOGIN OPTIMIZADA
# ==========================================================
fun_multilogin_optimized() {
    # 1. Obtener todos los usuarios de shell (UID >= 1000)
    local all_users=$(awk -F: '$3 >= 1000 {print $1}' /etc/passwd)
    local user limit conssh ovp
    
    # 2. Procesar el estado de OpenVPN una sola vez para evitar llamadas repetidas
    local ovpn_status_log="/etc/openvpn/openvpn-status.log"

    # 3. Iterar eficientemente
    while read -r user; do
        # Obtener el límite: usa el valor pre-cargado o 1 por defecto
        limit="${LIMITS[$user]:-1}" 

        # A. LIMITADOR SSH
        # Contar conexiones SSH (es la forma más rápida)
        conssh=$(ps -u "$user" | grep sshd | wc -l)

        if [[ "$conssh" -gt "$limit" ]]; then
            # Matar todas las conexiones del usuario (más simple y directo)
            pkill -u "$user"
            echo "SSH - Usuario $user ($conssh/$limit) excedido. Desconectado."
        fi

        # B. LIMITADOR OpenVPN
        if [[ -e "$ovpn_status_log" ]]; then
            # Filtrar las líneas del usuario en el log de OpenVPN (se mantiene grep/wc por ser archivo)
            ovp=$(grep -c -E ,"$user", "$ovpn_status_log") 

            if [[ "$ovp" -gt "$limit" ]]; then
                # Solo necesitamos matar una conexión para volver al límite (si limit=1, matamos 1)
                # Seleccionamos el CID (Client ID/Virtual IP) de la conexión más antigua (la primera línea)
                pidokill=$((ovp - limit))
                
                # Obtener los PIDs/IPs a matar (los primeros de la lista, que suelen ser los más antiguos)
                listpid=$(grep -E ,"$user", "$ovpn_status_log" | cut -d "," -f3 | head -n "$pidokill")
                
                while read -r ovpids; do
                    # Comunicación con la interfaz de gestión de OpenVPN
                    (
                        telnet localhost 7505 <<-EOF
                            kill "$ovpids"
                        EOF
                    ) &>/dev/null & # Se mantiene en background para no bloquear el bucle
                done <<<"$listpid"
                echo "OVPN - Usuario $user ($ovp/$limit) excedido. $pidokill sesiones eliminadas."
            fi
        fi
    done <<<"$all_users"
}

# ==========================================================
# PASO 3: BUCLE PRINCIPAL SIMPLIFICADO
# ==========================================================
while true; do
    echo "Verificando en $(date +%H:%M:%S)..."
    # Ejecutar la función en background para que el bucle pueda continuar si algo se bloquea.
    # No obstante, una función limpia no debería necesitar un & si el sleep es corto.
    fun_multilogin_optimized 
    sleep 15s
done
