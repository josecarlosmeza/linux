#!/bin/bash
# Script: dropbear_watcher.sh (CORREGIDO)
# Propósito: Monitorear continuamente sesiones Dropbear/SSHD y matar (KILL) aquellas que excedan el límite.
# Optimizado para bajo consumo de recursos (lee solo las últimas 5000 líneas y se ejecuta cada 10s).

# --- CONFIGURACIÓN ---
database="/root/usuarios.db"
AUTH_LOG_FILE="/var/log/secure"
LOG_KILL_FILE="/var/log/session_kill.log"

LOG_TAIL_LINES=5000 # Solo busca en las últimas 5000 líneas del log.
SLEEP_TIME=10       # Esperar 10 segundos entre ciclos.
# --- FIN CONFIGURACIÓN ---

get_active_session_count() {
    # CORRECCIÓN: Usar la variable de posición directamente sin barras invertidas o asignación problemática
    local target_user="$1" 
    local active_count=0
    
    # 1. OPTIMIZACIÓN: Solo buscar en las últimas LOG_TAIL_LINES del log
    SUCCESS_LINES=$(tail -n $LOG_TAIL_LINES "$AUTH_LOG_FILE" | grep -E 'Accepted password|Password auth succeeded|session opened' | grep -w "$target_user")

    if [[ -n "$SUCCESS_LINES" ]]; then
        local pids=""
        
        # 2. Extracción de PIDs (Dropbear y SSHD)
        pids+=$(echo "$SUCCESS_LINES" | grep "dropbear" | sed -E 's/.*dropbear\[([0-9]+)\].*/\1/')
        pids+=" "
        pids+=$(echo "$SUCCESS_LINES" | grep "sshd" | sed -E 's/.*sshd\[([0-9]+)\].*/\1/g')
        REGISTERED_PIDS=$(echo "$pids" | tr ' ' '\n' | grep -v '^$' | sort -u)

        # 3. Contar cuántos PIDs registrados siguen activos
        for pid in $REGISTERED_PIDS; do
            if ps -p "$pid" > /dev/null 2>&1; then
                active_count=$((active_count + 1))
            fi
        done
    fi
    echo "$active_count"
}

# --- BUCLE DE MONITOREO PRINCIPAL ---
while true; do
    while IFS=' ' read -r user s2ssh _ 
    do  
        user=$(echo "$user" | xargs)
        s2ssh=$(echo "$s2ssh" | xargs)
        
        if [[ -z "$s2ssh" || "$s2ssh" -eq 0 ]]; then
            continue
        fi

        # PASAR LA VARIABLE DE USUARIO LIMPIA A LA FUNCIÓN
        CURRENT_SESSIONS=$(get_active_session_count "$user")
        
        # LÓGICA DE TERMINACIÓN (Si el conteo excede el límite)
        if [[ "$CURRENT_SESSIONS" -gt "$s2ssh" ]]; then
            
            # Obtener TODOS los PIDs activos (ordenados de más nuevo a más viejo) para matar la sesión más reciente
            ALL_ACTIVE_PIDS=$(
                tail -n $LOG_TAIL_LINES "$AUTH_LOG_FILE" |
                grep -E 'Accepted password|Password auth succeeded|session opened' | 
                grep -w "$user" | 
                sed -E -e '/dropbear/! s/.*sshd\[([0-9]+)\].*/\1/g' -e '/sshd/! s/.*dropbear\[([0-9]+)\].*/\1/g' |
                tr -s ' ' '\n' | grep -v '^$' | sort -nr | # Ordena el PID más reciente (mayor número) primero
                while read pid; do
                    ps -p "$pid" >/dev/null 2>&1 && echo "$pid"
                done
            )
            
            PID_TO_KILL=$(echo "$ALL_ACTIVE_PIDS" | head -1)

            if [[ -n "$PID_TO_KILL" ]]; then
                kill "$PID_TO_KILL" 2>/dev/null
                echo "$(date): KILLED PID $PID_TO_KILL for user $user. Limit exceeded ($CURRENT_SESSIONS/$s2ssh)" >> "$LOG_KILL_FILE"
            fi
        fi
        
    done < "$database"
    
    sleep $SLEEP_TIME # Esperar 10 segundos antes de la siguiente verificación
done
